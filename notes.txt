SQL allows for four types of commands

create, read update delete. these four operations are called CRUD

sqlite3 favorites.db

.mode csv .import favorites.csv favorites
.mode table

.scheme < see struct of the database

SELECT * FROM favorites; - prints every row in the database

SELECT COUNT(*) FROM favorites; 

SELECT DISTINCT language FROM favorites; <-- all unique things
people selected (python, c, scratch)

SELECT COUNT(DISTINCT language) FROM favorites; <--- number
of unique languages people selected

GROUP BY
LIKE
LIMIT
ORDER BY
WHERE

SELECT COUNT(*) FROM favorites WHERE language = 'C';  <-----
how many people like C?

SELECT COUNT(*) FROM favorites WHERE language = 'C' AND pr
oblem = 'Hello, World'; <---------- how many people liked c
and hello world?

SELECT COUNT(*) FROM 
favorites WHERE language = 'C' 
AND (problem = 'Hello, World' OR problem = 'Hello, It''s Me');

SELECT COUNT(*) FROM favorites WHERE language = 'C' AND problem 
LIKE 'Hello, %';
^ more liberal than regular select query

SELECT language, COUNT(*) FROM favorites GROUP BY language <
how many people liked each individual language?

SELECT language, COUNT(*) FROM favorites GROUP BY language ORDER BY COUNT(*);
^ how many people liked each language, in sorted order?

SELECT language, COUNT(*) AS n FROM favorites GROUP BY language ORDER BY n DESC;
^ reverse sorted order with pretty aliases

SELECT language, COUNT(*) AS n FROM favorites GROUP BY language ORDER BY n DESC LIMIT 1;
^ gimme the most popular language in a nice table.

SELECT language as programminglang, COUNT(*) AS counter FROM favorites GROUP BY language ORDER BY counter DESC LIMIT 1; 
^ i wrote this query myself, making top language with nice categories

INSERT INTO table (column, ...) VALUES(value, ...)

INSERT INTO table (column, ...) VALUES(value, ...)

INSERT INTO favorites (language, problem) VALUES('SQL', 'Fiftyville');

DELETE FROM table WHERE condition;

DELETE FROM favorites; < destroys the entire table [dont do it]

DELETE FROM favorites WHERE Timestamp IS NULL;

UPDATE table SET column = value WHERE condition;

UPDATE favorites SET language = 'SQL', problem = 'Fiftyville'; <
obliterates the table, there is no undo, makes everyones favorite language
and SQL and fiftyville

---shows----

SELECT * FROM ratings LIMIT 10;

CREATE TABLE shows (
    id INTEGER,
    title TEXT NOT NULL,
    year NUMERIC,
    episodes INTEGER,
    PRIMARY KEY(id)
);

CREATE TABLE ratings (
    show_id INTEGER NOT NULL,
    rating REAL NOT NULL,
    votes INTEGER NOT NULL,
    FOREIGN KEY(show_id) REFERENCES shows(id)
);

last line - there is a relationship between this table and
another

within the world of sqlite, we have some datatypes available to us

BLOB < binary large object
INTEGER < simple numbers
NUMERIC < numbers, but dates/times/years etc
REAL < floating point values with decimal points
TEXT < strings

NOT NULL < when creating a table, what kinds of vals can be there

the database software itself can prevent you or other people
from removing or adding data to the database that shouldnt be there

UNIQUE 

SELECT * FROM ratings WHERE rating >= 6.0 LIMIT 10;
^ select from ratings with a bigger rating than 6, limit 10.

SELECT show_id FROM ratings where rating >= 6.0 LIMIT 10;

SELECT * FROM shows WHERE ID = 62614;

SELECT * FROM shows WHERE id IN (SELECT show_id FROM ratings WHERE rating >= 6.0) LIMIT 10;
select shows where their rating is bigger than 6, use SELECT show_id

SELECT title FROM shows WHERE id IN (SELECT show_id FROM r
atings WHERE rating >= 6.0) LIMIT 10;

sqlite> SELECT title FROM shows WHERE id IN
   ...> (SELECT show_id FROM ratings WHERE rating >= 6.0)
   ...> LIMIT 10;

JOIN

SELECT * FROM shows JOIN ratings ON shows.id = ratings.show_id WHERE rating >= 6.0 LIMIT 10;

SELECT title, rating FROM shows JOIN ratings ON shows.id =
 ratings.show_id WHERE rating >= 6.0 LIMIT 10;

joining tables together

SELECT genre FROM genres WHERE show_id = (SELECT id FROM shows WHERE title = 'Catweazle');

SELECT * FROM shows JOIN genres ON shows.id = genres.show_id WHERE id = 63881;

SELECT genre FROM shows JOIN genres on shows.id = genres.s
how_id WHERE id = 63881;

sqlite> SELECT person_id FROM stars WHERE show_id = (
(x1...> SELECT id FROM shows WHERE title = 'The Office' AND year =
(x1...> 2005);

sqlite> SELECT name FROM people WHERE id IN 
   ...> (SELECT person_id FROM stars WHERE show_id =
(x1...> (SELECT id FROM shows WHERE title = 'The Office' AND year = 2005));
^ all stars from the Office

sqlite> SELECT title FROM shows WHERE id IN
   ...> (SELECT show_id FROM stars WHERE person_id =
(x1...> (SELECT id FROM people WHERE name = 'Steve Carell'));
^ all shows steve carell has been in

sqlite> SELECT title FROM shows
   ...> JOIN stars ON shows.id = stars.show_id
   ...> JOIN people ON stars.person_id = people.id
   ...> WHERE name = 'Steve Carell';

sqlite> SELECT title FROM shows, stars, people
   ...> WHERE shows.id = stars.show_id
   ...> AND people.id = stars.person_id
   ...> AND name = 'Steve Carell';

indexes

CREATE INDEX title_index ON shows(title);
^ speeds up queries by several orders of magnitude
underneath the hood, they make a B-tree data structures

B-Trees (dsa?)

sqlite> SELECT title FROM shows where id IN
   ...> (SELECT show_id FROM stars WHERE person_id =
(x1...> (SELECT id FROM people WHERE name = 'Steve Carell'));

sqlite> SELECT title FROM shows WHERE id IN
   ...> (SELECT show_id FROM stars WHERE person_id = 
(x1...> (SELECT id FROM people WHERE name = 'Steve Carell'));

index is BLAZING fast using b-trees to spead up queries. 

BEGIN TRANSACTION
COMMIT
ROLLBACK

SQL injection attacks

never trust user input